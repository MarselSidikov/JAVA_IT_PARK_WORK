cd - смена директории в командной строке
dir - содержимое директории
javac - компиляция в байт код
java - вызов виртуальной машины и исполнение в ней программы
class ИмяКласса - всегда с большой буквы аналогично с названием файла.
args в main - это аргументы командной строки
______________________________________
Программа - алгоритм + структура данных
алгоритм - последовательность действий с пятью свойствами:
1) ввод
2) вывод
3) эффективность
4) конечность
5) однозначность/детерменированность
Теорема Бема-Якоппини - любой алгоритм можно выразить с помощью комбинации трех структур управления (на доске).  
_____________________________________________
УСТАНОВКА JDK:
JRE - Java Runtime Environment - Java окружение для выполнения программ (JVM)
JDK - JavaDevelopmentKit - набор инструментов (javac)
Установить JDK:
http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
<прописать путь к javac> переменные среды windows 10 java
java -version
javac -version в cmd либо в git bush
ПОДГОТОВКА К ДОМАШКЕ:
а) Скачать git for windows https://git-scm.com/downloads
б) установить Git Bush Only 
в) Регистрация https://github.com/
г) Скидываете мне ссылку на git: https://github.com/ВашЛогин в диалог
д) Переходите во вкладку Repositories
е) Нажимете кнопку new
ж) В Repository name вводите JAVA_IT_PARK_WORK
з) Нажимаете Create Repository
и) В пункте Quick Setup копируете строку с ссылкой
к) Запускаете Git Bush
л) Вводите cd Desktop
м) Вводите git clone https://github.com/ВашеИмя/JAVA_IT_PARK_WORK.git
н) Устанавливаете Sublime Text и открываете эту папочку в нем
о) Теперь вся ваша работа ведется в этой папке
п) Сделали всю свою работу - создаете папку HomeWorks - и в ней подпапки TaskНомерЗадачи
В каждой папке Program.java
р) В Git Bush делаете git status
c) git add .
т) делаем git commit -m 'add homework'
у) git push origin master - только один раз (потом git push).
ЗАМЕЧАНИЕ: 
Перед первым коммитом надо будет сделать
git config —global user.email [email регистрации]
git config —global user.name [ваше имя]
______________________________
ДЗ:
1. Посчитать произведение простых чисел в последовательности ( пока не -1)
2. Посчитать сумму чисел, порядок вхождения которых - четное число
34 - 1
56 - 2
78 - 3
21 - 4
-1
3. Посчитать произведение чисел, сумма цифр которых - простое число.
4. Развернуть массив на месте
5. Сумма элементов массива
6. прозизведение четных элементов массива, стоящих на нечетных позициях.
-------------------------------------------
Типы данных в java: int, double, boolean, char, short, byte, long, float (примитивные типы) - переменные данного типа, непосредственно хранят в себе значение.

Ссылочные - массивы.
------------------------------------
ДЗ:
7) Найти количество локальных максимумов в массиве. 
a[i-1]<a[i]>a[i+1], i = 1..n-2
Например: 1, 3, 2, 5, 4, 3, 1; - 3 и 5 - локальные максимумы

---------------------
Многомерные массивы в java - массив массивов
Функция:

public static ТИП_ВОЗВР_ЗНАЧЕНИЯ имя_функции(список_формальных_параметров) {
	// тело функции
	return значение;
}

Функции с одинаковыми названиями, но разными формальными параметрами называются перегруженными.

ДЗ:
В виде процедур и функций:
8) Найти среднее арифмитические в матрице
9) Найти минимальный элемент в каждой строке матрицы
10) Обнулить все элементы главной диагонали квадратной матрицы
11) Обнулить все элементы на побочной диагонали
12) Сделать разворот против часовой стрелки в квадратной матрице
13) Найти максимальный элемент в каждом столбце матрицы
14) Написать функцию проверки числа на простоту. (boolean-функция)
15) Написать функцию, возвращающую сумму цифр числа
----------------------------
ЗНАЕМ:
java - исполняет
javac - компилирует
Типы данных в java - примитивные/ссылочные
Переменные + явное/неявное приведение, операции / и %
if, while, for
функции и процедуры
Массивы - явная инициализация, многомерные массивы
Алгоритмы: поиск минимального, максимального, поменять местами значения, среднее арифметическое
Git - git clone, git add ., git commit, git push, git pull

Рекурсия - стек вызовов, терминальное условие рекурсии.

Ряд Фибонначи 
x[n] = x[n-1] + x[n-2], x[0] = 1, x[1] =1

x[2] = 2
x[3] = 3
x[4] = 5

ДЗ:
16) Оптимизировать вычисление Фибонначи
-------------------------------------------
Сортировка простыми вставками:

[42] [13] [5] [-10] [11] [2] [10]
   0    1   2     3    4   5    6

[0..6]
a = 0
b = 6
Минимальный элемент: -10
Меняем x[0] -> x[3], получаем:
[-10] [13] [5] [42] [11] [2] [10]

Теперь а = 1
[1..6], там минимальный - 2
 Определяем промежуток индексов [a..b]. 
 В этом промежутке находим минимальное число. Далее, заменяем минимальное число с числом x[a], изменяем промежуток a = a + 1, повторяем вычисления.
--------------------------------
ООП:
Парадигма программирования - способ организации вычислений внутри программы + стиль мышления программиста при решении задачи
Процедурная парадигма программирования: программа = алгоритм + структура данных
Функциональная парадигма:
программа - есть функция
Парадигма логического программирования: программа = набор логических предикатов (функции с true и false).
Парадигма ООП:
программа = объекты, которые обмениваются сообщениями.

ООП оперирует понятиями классов и объектов.

Объект - конкретная сущность, обладающая состоянием (свойствами) и поведением (действия).

Класс - абстрактный тип данных. Класс описывает то, каким поведением будут обладать созданные на основе класса объекты, и какие возможные состояния они могут иметь.

Возможное состояние объекта задается в классе.Задается с помощью полей (fields).

Инстантивация - выделение памяти и создание объекта (оператор new).

Инициализация - задание начального состояния

Конструктор - инициализатор (не является членом класса) - задачей конструктора является присвоение начальных значений полям объекта при создании.

Конструктор по умолчанию - конструктор, определенный для всех классов изначально. Конструктор по умолчанию имеет вид ClassName();
Он присваивает полям нулевые значения
int -> 0
double -> 0.0
String -> null
Для ссылочных типов -> null
boolean -> false
char - '\0'
Конструкторы можно переопределять. Как только вы описали свой конструктор, конструктор по умолчанию - отключается

ООП-разработчик:

Роль 1 - разработчик класса
Роль 2 - пользователь класса

Иногда возникает необходимость предоставить пользователю класса возможность проинициализировать объект своими данными. Для этого следует определить конструктор с параметрами

Инкапсуляция:
1) Совмещение алгоритмов и структур данных в одной сущности - классе.
Алгоритмы в классе реализуются в виде функций, структуры данных в виде полей.
Функции и процедуры внутри класса называются методами.
Методы - члены класса.
2) Защита внутренней структуры данных с помощью модификатора private - закрывает доступ к члену класса извне.

Поля всегда защищаем модификатор private
Если необходимо читать/изменять - делаем методы доступа - сеттеры геттеры.
Если необходимо только читать - только геттеры

5 классная) Описать класс Рациональное число
RaionalNumber.java
поля - числитель, знаменатель
конструктор с параметрами и без
метод нормализации - 5/2, метод должен вернуть 2.5

1) Один файл - один класс
2) Никакого транслита
3) int x = 6;
4) class Class {}

Объектные переменные (ссылочные переменные, указывающие на объект)

Модификаторы доступа:
public 
private
protected

Четыре уровня доступа
Открытый - public
Закрытый - private
Защищенный - protected
package internal - нет

Статическое поле - поле, глобальное для всех объектов класса.
Значение статического поля можно задать вызвав класс.

Статический инициализатор - инициализирует значения статических полей - работает ТОЛЬКО со статическими полями.

Статический метод - метод, вызов которого возможен без создания объекта, непосредственно из класса.
СТАТИЧЕСКИЙ МЕТОД ТОЖЕ СО СТАТИЧЕСКИМИ ПОЛЯМИ БЛИН
РЕЗЮМЕ:
Класс состоит из:
Закрытых полей
Конструкторов
Методы доступа
Прочие методы
Статические поля
Статические методы
Статические инициализаторы

n * n ~ O(n^2)

n^3 + n^2 + n ~ O(n^3)

СРЕДНИЙ ЛУЧШИЙ СЛУЧАЙ O(N * logN)
-------------------

Сортировка слиянием.

Слияние:
c[] <- merge(a[], b[])
a = {4, 5, 7, 10, 11}
b = {1, 2, 6, 8, 9, 13};

4 ~ 1 
c <- 1
4 ~ 2
c <- 2
4 ~ 6
c <-4
5 ~ 6
c <- 5
и т.д.

Реализовать класс Sort, в нем
статический метод merge(int a[], int b[])
https://github.com/IlyasGaynulin/JAVA_IT_PARK_WORK/blob/master/ClassWorks/Task6/Sort.java

Сортировка слиянием:

с = 10 -8 1 2 4 3 1 0
a = {10, -8, 1, 2}
b = {4, 3, 1, 0}
Сортировать c: 
 - Сортировать a
   - положить, что c = a
   	 c = {10, -8, 1, 2}
   	 a = {10, -8}
   	 b = {1, 2}
   	 Сортировать a, сортировать b
   	 Слить a и b
   	 - положить, что c = a
   	 c = {10, -8}
   	 a = {10}
   	 b = {-8}
   	 c <- {-8, 10};
Сортировать b
Слить а и b

ДЗ:
17) Создать массив людей, сортировать пузырьком по возрасту
18) Вывести количество всех возрастов от 1 до 120;
ДОП: разобрать код merge

Наследование - третий принцип ООП.
Предоставляет возможность объектам класса потомка
копировать и переопределять поведение и состояние
объектов класса предка.

extends - ключевое слово, которое показывает что класс наследуется.
class A extends B - класс А - потомок класса B
protected - модификатор доступа, соответствует уровню
доступа "защищенный". Члены класса, которые помечены как
protected видны в потомке
super(a,b,c) - вызов конструктора предка.
В конструкторе потомка вы всегда обязаны вызывать консруктор предка
в первую очередь.

Переопределение метода - это объявление в классе потомке
метода с идентичной сигнатурой метода класса предка, но
с другой реализацией

Полиморфизм - четвертый принцип ООП. С объектами разных
типов можно работать таким образом, будто они принадлежат
одному типу.

Восходящее преобразование - преобразование типа объектной переменной
с типа класса-потомка на тип класса-предка (НЕВНОЕ)


Task7 Создать класс SuperHero
У него два потомка - Mutants и Humans.
И у того и у того класса есть количество
 врагов.
Написать метод сортировки массива
супергероев
по количеству врагов.

Абстрактный класс (модификатор abstract) - класс, объекты
которого создавать нельзя.
Абстрактный метод - метод без реализации.
Данный метод необходимо реализовать в потомках.
Если в классе есть хотя бы один абстрактный метод,
класс нужно пометить как абстрактный.
Если в классе потомке абстрактный метод не реализован,
то класс-потомок тоже следует пометить как абстрактный.

У класса не может быть более одного предка.

Давайте подумаем:
Presentable - это инкапсуляция поведение, а для инкапсуляции
поведния подходят интерфейсы.

Интерфейс - это описание поведения. Классы реализующие (имплементирующие)
интерфейс обязуются реализовать ВСЕ методы интерфейса, иначе
они должны быть помечены как абстрактные.

Класс может реализовывать более одного интерфейса (просто перечисляем их
через запятую).

https://ru.wikipedia.org/wiki/%D0%90%D0%B3%D1%80%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

ЭКЗАМЕН:
1) Практическая
2) Теоретическая

1) Типы данных в Java
2) Приведение типов
3) Структуры управления + Теорема Бема-Якоппини
4) Подпрограммы - функции и процедуры (формальные параметры и аргументы)
5) Классы и объекты (структура, члены классов) + инкапсуляция
6) Статические члены классов
7) Инициализаторы
8) Наследование - protected, abstract, super.
9) Интерфейсы
10) Класс Object и его методы - equals и toString
11) Comparable + Comparator
12) Исключения
13) JavaIO
14) characters

19) Создать класс ParkingPlace (парковка
- парковать паркуемый объект 
- пусть он уедет с парковки по номеру
Класс содержит массив "паркуемых объектов"
ParkingObject - интерфейс
getNumber()
Паркуемый объект - parking() и unparking()
Есть иерархия классов:
Транспорт - абстрактный
Машина
Мотоцикл
Велосипед - не паркуемый объект!!!
Перепределить equals, toString

Коллекции - набор элементов

Список - абстрактный тип данных
поддерживающий операции:
добавить элемент в список
вставить элемент в список
удалить элемент по номеру
получить элемент по номеру
найти элемент по значению
развернуть список
получить количество

20) Дореализовать ArrayList

Object - предок всех классов. Да, всех. Абсолютно всех, нет классов которые не являются его потомками.
Ваш класс, который вы написали, тоже потомок Object

== - сравнивает значения примитивных типов
в случае ссылочных типов проверяет эквивалентность ссылок

Задача - алгоритмы сортировки - как сортировать
одним алгоритмом объекты разной природы?
Определить интерфейс Comparable с методом
compareTo(Object object) и реализовать его
в классе сортируемых объектов
Если нас не устраивает реализованный compareTo
то описываем свой интерфейс Comparator и там
уже говорим, как сравнивать объекты


-------------------------------
Ислючительная ситуация - неккоректная работа
программы в момент выполнения
Для каждой исключительной ситуации в java
описан класс.
StackOverflowError
OutOfMemoryError
ArithmeticException

Чтобы перехватить исключение необходимо:

try - помечаем блок кода, в которой может возникнуть
исключительная ситуация
catch(E e) - блок, в котором мы описываем, что
нужно делать, если перехвачена ошибка типа E
e - объект ошибки
throw new - выброс ошибки

TASK 8

Описать класс верификатор
в нем сделать проверку корректности пароля:
Метод verify принимает на вход пароль,
и выдает PasswordException, если длина пароля
меньше 6 символов. В противном случае, ничего не делает.
В мейне - считать пароль и проверить на корректность.
Если выскочила ошибка PasswordException
попросите пользователя ввести заново.

В Java следующая иерархия исключений:
Throwable - все, что может быть
выбрашено в качестве исключения
Два потомка Throwable:
Error - ошибки системы (его потомок VirtualMachineError,
потомками которого в свою очередь являются StackOverflowError и OutOfMemoryError)
ВСЕ ЭРРОРЫ МОЖНО ПЕРЕХВАТЫВАТЬ try-catch
Exception - все проверяемые исключения (то есть те, которые вы обязаны обработать либо пробросить наверх throws)

Поток (Stream) не путать с Потоком (Thread)
- последовательность байтов
При запуске программы по умолчанию
открываются три потока
System.out
System.err
System.in

JavaIO - набор классов для работы с вводом-выводом
В иерархии классов наверху находятся
InputStream и OutputStream

InputStream - абстрактный класс, описывает поведение
чтения потока с методами
read()
read(byte b[])
FileInputStream - файловый поток

ТАБЛИЦА СИМВОЛОВ - таблица, где каждому
символу сопоставляется число, которое копьютер
может как-то идентифицировать.

Набор символов определяется кодировкой
Если файл закодирован кодировкой ASCII, то каждый
символ в этом файле весит 1 байт.
ASCII
0 - 31 - Управляющие символы
примеры:

0 -
1 -
9 - таб
10 - новая строка
13 -возврат каретки
...
33 - 126 - символы, цифры и буквы английского алфавита

UNICODE - один символ - 2 байта

ДЗ
21) написать функцию конвертации числа как строки
вход - char[] ~ '3','2','1'
выход - 321 (int)



ДЗ
Экзамен
ДЗ ParkingPlace -
Ильяс,
Айдар,
Михаил,
Алина,
Марсель

10-я задача
Создать проект Task10
Список фигур записать в файл
1) Описать классы фигур
2) переопределить toString
3) OutputStream - записать в файл список фигур

-----------
20) Сделать ArrayList обобщенным
ИЗУЧИТЬ ОБОБЩЕНИЯ В Compare

Связный список (LinkedList) - структура данных,
представляющая собой набор элементов.
Каждый элемент хранится в узле (Node) связного списка.
Каждый узел списка состоит обязтаельно из двух полей:
Value - значение элемента списка
Next - указатель на следующий элемент списка

ДОП: читать про внутренние классы и вложенные классы

DAO - паттерн проектирования
Data Access Object - объект доступа к данным
Проблема:
    данные могут хранится в каком угодно виде,
    при этом часто формат хранения данных меняется
    необходимо разделить логику работы системы
    и логику работы с хранилищем данных

Singleton
Properties-файл
Iterator

ДЗ:
1) Повторить
Сделать:
22)Реализовать метод findAll в HumansDao через LinkedList или ArrayList
который написали вы сами.
23) В LinkedList реализовать remove(int index)
Реализовать reverse() - разворот связоного списка
--------------

Задача: научиться хранить 
данные типа <Ключ, Значение>,таким образом
чтобы мгновенно получать доступ 
к значению по ключу.

Пусть ключ - строка.
Мы знаем, что в массиве доступ к элементу по 
ключу-индексу моментальный. Значит надо
научиться преобразовывать ключ-строку в индекс.

Пусть имеем безразмерный массив A
[ ] [ ] [ ] ... [ ] - значения
 0   1   2      m - 1 - ключи-индесы
 
 1) Пусть есть строка ABBC, ее ключ-индекс считаем
 как сумму кодов символов
H1 = (int)'A' + (int)'B' + 
(int)'B' + (int)'C', данное число и будет 
индексом, где храним ключ ABBC
ПРОБЛЕМА - что H1(BABC) = H1(ABBC), в одну 
ячейку кладем два ключа - это плохо.
Решение: учитывать позицию

H1 = S[0] + S[1] + ... + S[n - 1]
предложим H2:

H2 = w1 * S[0] + w2 * S[1] + ... + wn * s[n - 1]
wi при S[i] будем считать как p^i
ВОПРОС: каким должно быть p?
p - четное, появляется множитель 2.
Пусть имеем число x = 113, его двоичный код - 1110001
Умножим его на 2: x = 226, его двоичный код -11100010
Умножим еще раз на 2: x = 452, 				111000100
Если брать p-четным, мы постоянно теряем информацию
Умножение на два - это сдвиг влево на один бит.
p - нечетное, пусть 63 - 3, 7, 9, 21
Если в сумме будут всплывать комбинации этих чисел
3 * 21, 9 * 7, 3 * 3 * 7.
p - ПРОСТЫЕ
Обычно p = 31
Таким образом, формула получения ключа-индекса
из ключа-строки
H = SUM 31 ^ i * S[i], i = 0..n-1
H - хеш-код

-------------------------------------------

Хеш-код получили, но он нереально огромный
Надо урезать до размеров массива.
Как вариант можно оставить последние биты, которых
достаточно для определения индекса.

Маска - битовая последовательность, которая позволяет
маскировать другую битовую последовательность:

маска - 110011
исходная последовательность - 001110

Применяем маску через конъюнкция (И)
110011
001110
------
000010 - результат масирования

--------------------------------
Исходная строка - Marsel
Ее хеш -1997431204
Хеш в двоичном коде - 10001000111100011001111001011100
Размер массива - 11
Маска 11 - 1 = 10, в двоичном коде 1010
Применяем маску:
10001000111100011001111001011100
							1010
							----
							1000 - 8, позиция
							
При плохом выборе размера массива, а следовательно
маски, могут возникнуть КОЛЛИЗИИ, когда одна позиция
на несколько ключей.
ПОДОБРАТЬ ПРАВИЛЬНО РАЗМЕР!
2^k - 1



-----------------
Работа с двоичными числами в комьютере:

-12 в десятичной - 11110100

Помним, что первый бит отводится под знак.

23 - 12, компьютеру не удобно вычитать, он заменит
операцию вычитания сложением:
23 + (-12), как получить -12?
Пусть у нас число хранится в одном байте, тогда:
12 -> 00001100
Получаем обратный код:
-> 11110011
-> Получаем дополнительный код, к обратному прибавляем
единичку
-> 
 11110011
		1
---------
 11110100


Возвращаемся к 23 - 12
	00010111
    11110100
	--------
   100001011 -> 1011

-------------------------
Проблема - коллизии так и так будут, потому что
места всегда мало.

Решение метод цепочек - каждый элемент массива 
- связный список.

Map - АТД, карта, словарь, ассоциативный массив
Таблица Ключей и Значений.
Где ключ - любой объект.
----------------------
Если в классе A необходима функциональность класса B:
1) Плохой - наследование (изменение B влечет изменения в A)
2) Лучше - агрегирование (в A есть поле B)
3) самый лучший - агрегирование со слабой связью
Делаем прослойку интерфейс.
+ можно подменить реализацию в любой момент
+ измение функциональности реализаций интерфейса никак 
не отражается на исходном классе
----------------------------
Рефлексия - возможность работать с классами
как с объектами
Получить объект-класс H типа Class:
Class clazz = H.class;
clazz.getFields() - получить все открытые поля
clazz.getDeclaratedFields() - получить все поля, в том числе закрытые.

ДЗ:
24) Реализовать в HashMap 
V get(K key)
25) Поработать с методами в рефлексии, получить метод класса и вызвать его.

----------------------------------
РАЗБОР ДЗ:
9 - вернуть МАССИВ МИНИМАЛЬНЫХ
13 - аналогично
16 - скинул в вк
18 - у вас массив чисел [0..120], массив людей
у каждого возраст
for (int i = 0; i < humans.length; i++) {
	int currentAge = humans[i].getAge();
	ages[currentAge]++;
}
19) Парковка:
ParkingPlace
 - ParkingObject[]
	+ park()
	+ unpark()
	
не все транспорты паркуемые!!!
21) "12345" -> int = 12345
----------------------------------

Чем плохи файлы в качестве хранилища
1) Нет формализованного понятия строки данных
2) Нет проверок на целостность и корректность
3) Нет транзационной безопасности
Базы данных:
все это есть =)

Реляционные базы данных:

База данных состоит из таблиц, 
связанных реляционным соотношением

1. есть таблица дочерняя
2. есть таблица родительская

Таблица "Пользователь" - родительская   
Колонки: id Имя Возраст

Таблица "Автомобили" - дочерняя
Колонки: id Модель Номер id_владельца

id_владельца ссылается на таблицу "Пользователь"
на колонку id

SQL базы данных - реляционные базы данных + язык SQL
PostgreSQL - одна из разновидностей
Есть еще: MySQL, Oracle DB, Transact-SQL, SQLite

Создание БД в pgAdmin
1. Выбор сервера
2. Базы данных
3. Правой кнопкой мыши -> Новая база данных
4. Вносим имя и ОК

Выбор БД и таблиц:
Серверы -> Базы данных -> Наша БД -> Схемы -> public -> Таблицы

CREATE TABLE - создание таблицы, указываем колонки и их типы
SERIAL - автоинкремент, данный столбец запо
лняется автоматически
PRIMARY KEY - первичный ключ - он уникален для всей таблицы.
Каждая строка таблицы будет иметь уникальное значение в этой колонке


ЗАДАЧА:
Создать БД ФАМИЛИЯ_DB
Там две таблицы (как у меня)
заполнить данными

Поделать Селекты

------------------------------
Работа с БД в java

ТЕЗИС: БД много, а java - одна
Драйвер базы данных - библиотека, которая
обеспечивает взаимодействие БД с java-кодом

JDBC - Java DataBase Connectivity
PostgreSQL -> 

1. Connection - соедение с базой данных
2. Statement - выражение, которое можно передать в БД и получить результат
3. PrepareStatement - прекомпилированный запрос, то есть строка запроса подается сразу при создании выражение
4. ResultSet - итератор, указывающий перед строками результата 


Модульное тестирование:
1. Тестирование отдельных модулей (классов).
2. Написание тестов проводится программистом
3. Позволяет автоматически проверять ожидаемое с реальным
4. Позволяет избежать регрессии кода

Правила модульного тестирования:
1. тест - один метод
2. тест - это один случай
3. всегда возвращать систему в исходное состояние после теста
4. Один метод - один assert
5. Тестировать в тотальной депресси и плохом настроении

--------------------------------------
Принципы Ioc и DI

Система - это набор компонентов.
Каждый компонент - это отдельная 
вполне заменяемая сущность.
Реализацию любого компонента можно заменить
без нарушения функциональности системы.

IoC - Инверсия управления. Паттерн, который
говорит о том, что НАДО КОМПОНЕНТЫ ОПИСЫВАТЬ ОТДЕЛЬНО,
А СВЯЗЫВАТЬ ОТДЕЛЬНО

Что значит связывать? Что значит связь?

class A {
	private B b;
	
	public A() {
		this.b = new B();
	}
	
	public void someMethod() {
		b.someMethod();
	}
}

Класс A и B сильно связаны.

Варианты решения - сделать интерфейс С.

class A {
	private C c;
	
	public A(C c) {
		this.c = c;
	}
	
	public void someMethod() {
		c.someMethod();
	}
}

Теперь компонент B заменим. В А  можно передать
любой объект с фукциональностью C.

В идеале - вся система это наборы интерфейсов,
и их реализациий.

Кто создает и связывает компоненты?
Для этого и существует специальный IoC-контейнер.

ДЗ:

1) ДОделать DAO на JDBC
2) Изучить проект Service
3) Посмотреть мои модульные тесты


---------------------
Spring Framework

В центре всего - бины.
Бин - это компонент. Либо класс, либо объект,
либо примитивный тип.

Все бины находятся в IoC-контейнере.
ApplicationContext(интерфейс)
и есть IOC-контейнер(скорее, описывает поведение контейнера).
Главные методы:
Object getBean(String beanId)
<T> T getBean(Class<T> beanClass)
ClassPathXmlApplicationContext - тащит
бины из XML-ки

Maven - система сборки.

Сборка:
1) Компиляция
2) Прогон модульных тестов
3) Упаковка jar-архива
+ скачивание зависимостей и их подключение

Maven удобен:
1) Сам скачивает зависимости
2) Сам ищет подзависимости
3) Сам собирает проект
4) Сам прогоняет модульные тесты

Структура maven проекта:

- src - файлы исходного кода
    - main - главные файлы кода
        -java
        -resources
    - test - модульные тесты
- target - скомпилированные файлы + jar
- pom.xml - файл maven-проекта

Проект описывается:
groupId - идентификатор организации
artifactId - идентификатор проекта
version версия

Как maven работает с зависимостями:
1) Видит зависимость, ищет ее в папке .m2
2) если в папке .m2 нет такой зависимости, ищет в интернете
и скачивает ее в .m2 а потом подключает к проекту

Фазы сборки maven:
1) clean - очищает папку target
2) compile - .java -> .class
3) test
4) package - все упаковывает в jar
5) install - копирует jar В .M2


------------------------------------------------
Можно использовать профили.
То есть каждый набор бинов соответствует определенному профилу.

Чтобы сделать возможной работу с профилями из Java
Вместо ApplicationContext необходимо использовать
GenericXmlApplicationContext.
У него получаем набор окружений
ConfigurableEnvironment environment = context.getEnvironment();
Задаем необходимый профиль и загружаем контекст из xml

------------------------------------------
JdbcTemplate + NamedParameterJdbcTemplate
По сути одно и то же.

JdbcTemplate обертка над Jdbc. Вам не придется думать
о Statement, о Connection и о работе с ResultSet.

NamedParameterJdbcTemplate позволяет работать с именоваными
параметрами - :name, :age

RowMapper - отображает строку ResultSet в объект
согласно написанному Вами правилу

ЗАДАЧА:
Создать maven-проект
groupId = ru.itpark
artifact-id = sidikov_project
version = 0.1

В pom.xml добавить spring, postgres

Архитктура проекта:
ru.itpark
    - dao
        - BaseCrudDao
        - ModelNameDao
        - ModelNameDaoJdbcImpl
    - service
    - models

Создать context.xml c единственным профилем "dev"
Там описать бины на DataSource, ModelNameDao, Service
-------------------------------------------------
Продумать предметную область вашего проекта, накидать
модели, накидать схемы баз данных в каталоге resources
в подкаталоге ru.itpark.sql (сделать файлы create table).sql
Попробовать модульно потестировать

---------------------------
Тестирование DAO

Проблема - нет базы данных, она удаленная, она тяжеловесная.
Решение - создать временную встроенноую (embedded базу данных)
Какие СУБД подходят на эту роль?
H2 или HSQLDB

Как решаем проблему в контексте спринга:
1. Загружаем драйвер для H2 (см. pom.xml)
2. Добавялем профиль в context.xml
3. Указываем ссылки на схемы и их расположение:
xmlns:jdbc="http://www.springframework.org/schema/jdbc"
// внутри schemaLocation
http://www.springframework.org/schema/jdbc
http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd
4. Указываем другой DataSource (см. context.xml) со скриптами для
тестов
----------------------------
WEB

1. Клиент-серверное взаимодействие

Сервер - программный модуль, размещенный на удаленном
комьютере (сервере). Содержит основную логику
работы системы. Содержит функционал для работы
с хранилищем данных, отвечает на запросы клиента.

Клиент - программный модуль, размещенный на локальном
компьютере, содержащий минимум логики, отправляющий
запросы серверу.
В завимости от количества логики клиента, 
говорят о тонком клиенте, толстом и среднем.

Способы взаимодействия клиент-сервера:

HTTP-протокол

1. Запросы - от клиента
	- url-запроса
	- метод запроса - GET, POST, PUT, DELETE ...
	- параметры запроса(ключ, значение) - прикрепляются к url запроса через ?-знак, если более одного параметра - &
	- тело запроса - только для POST, PUT запросов
	- заголовки - сопроводительная информация
	
	* В браузере запросы по умолчанию уходят на 80-й порт сервера.
2. Ответы - от сервера на запросы клиента
	- статус ответа - 404, 200, 201, 500, и др.
	- заголовки ответа
	- тело ответа
	
HTTP в Java

Для реализации клиент-серверного взаимодействия
в java предусмотрены сервлеты.

Сервлет (интерфейс Servlet)- сущность, отвечающий за клиент-серверное взаимодействие.
HttpServlet - сервлет, работающий на HTTP
Имеет методы - doGet, doPost и т.д.
Каждый из методов реагирует на свой тип запроса.
Каждый метод принимает на вход
HttpRequest и HttpResponce.

Сервлеты должны быть объедены в какой-либо архив.
Обычно это war-архив (Web-архив).

Данный архив сервлетов необходимо разместить 
в контейнере сервлетов (Tomcat)

Размещение war архива в контейнере сервлетов
называется деплоем. (deploy).

Для того, чтобы томкат знал о том, какие сервлеты есть
в архиве и на какие url-ы запросов они отвечают, 
необходимо прописать web.xml

Работа с Tomcat+Maven в intellij IDEA:

Создать maven проект

Указать, чтобы он собирался как war-архив

Подключить зависимость с сервлетами

Описать сервлеты - отнаследовать класс HttpServlet и переопределить необходимые методы, например doGet, в качестве параметров он принимает - HttpServletRequest и HttpServletResponce.

Создать и настроить конфигурацию war-файла - создать папку webapp, создать подпапку WEB-INF, и создать файл web.xml

Внутри web.xml описываем сервлеты и говорим, на какие запросы он должен реагировать (путь).

Настраиваем tomcat в IDE:

Run -> Edit Configurations -> + -> Tomcat Server -> Local,  Name -> Tomcat

Вкладка Deployment -> + -> Artifact -> Выбираем первый war-файл

Возвращаемся во вкладку Server, чистим Before Launch, там же набираем RunMavenGoal, и пишем clean package

Что имеем:

При запуске приложения сначала произойдет сборка maven-ом
Запустится tomcat
На томкат задеплоится приложение
Tomcat обычно запускается на порту 8080

----------------------------

JSP:

1. Файл, совмещающий java + html + теги-jstl
2. Данный файл компилируется в обычный Servlet (Jasper-ом)
3. Отдает данные через writer респонса.

Для того, чтобы в JSP работали теги, например (foreach)
надо в jsp добавить строку 
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>

В pom.xml зависимость:
<dependency>
        <groupId>jstl</groupId>
        <artifactId>jstl</artifactId>
        <version>1.2</version>
</dependency>

http://localhost:8080/users?view=list

1) Сделать на JavaFX приложение, где будут:
Текстовое окно для ввода id человека
Текстовое окно для ввода count-друзей
Кнопка, при нажатии на которую программа выдаст
окно со списком друзей этого пользователя

https://github.com/MarselSidikov/BestOnlineService/wiki

2) Написать свой сервер по моему шаблону.
На отдачу данных.
--------------------------------------------
API - сервера, множество методов, с помощью
которых мы можем получать данные с сервера и реализовывать
определенную логику на клиенте.

Пример:
http://localhost:8080/users/1?select=with_auto

На такой API-запрос мы получим JSON-файл с необходимыми 
данными.

Структура Java-сервера, который обрабатывает такие запросы:
- models - Модели бизнес-логики системы (сущности)
- dao - классы-интерфейсы для работы с данными (с БД)
 * JdbcTemplate
 * Hibernate (SessionFactory - устаревшая)
 Настройка ORM-маппинга в Hibernate
 1) HBM-файлы (+ конфигуриемость, не надо переписывать код, - читаемость)
 2) Аннотации (+ читаемость, - необходимость перекомпиляции)
 Настройка Hibernate
 - DataSource - бин-подключения к БД
 - SessionFactory - бин настройки Hibernate
- services - слой бизнес-логики, обертка над DAO
- controllers - слой сервлетов, обрабатывающих запросы
к серверу. Контроллеры - это сервлеты внутри инфраструктуры Spring

@GetMapping(value = "users/{user-id}", 
params = "select=with_auto")
    public User getUserWithAuto(@PathVariable("user-id") int userId) {
        return service.getUserWithAuto(userId);
    }

	@GetMapping - метод, помеченный данной аннотацией 
	вызывается тогда, когда от клиента поступил GET-запрос
	value = "users/{user-id}" - означает,
	что метод, помеченный данным параметром аннотации
	будет вызван тогда, когда URL-запроса будет
	подходит под указанный шаблон
	params = "select=with_auto" - означает, что метод,
	помеченный данным параметром аннотации, будет 
	вызван тогда, когда в параметрах запроса будет
	стоять параметр select со значенеим with_auto
	@PathVariable("user-id") int userId	- в переменную
	userId будет положено значение, которе стоит в позиции
	user-id
	@RestController - данной аннотацией помечается класс,
	результатом выполнения которого всегда 
	будут модели, сконвертированные в JSON
	
Конфигурация Spring в данном проекте:
1. context.xml, в нем мы прописывали бины. ->
заменили JavaConfig (только один джава-класс, который отвечает
за конфигурацию проекта)

@Configuration - данной аннотацией помечается класс
конфигурации Spring
@ComponentScan("ru.itpark") - аннотация говорит о том,
что компоненты системы Спрингу надо искать в этом 
пакете
@Bean - данной аннотацией помечается метод, создающий определенный бин
@Autowired - навешивается на поля, на конструкторы
Означает что в это место нужно автоматически произвести
инджект (связывание) подходящего по типу бина.
@Component - аннотация вешается на класс, объект
которого будет бином

Конфигурация сервлетов:
- раньше - web.xml
- теперь - AppInit





























