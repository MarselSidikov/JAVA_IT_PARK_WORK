cd - смена директории в командной строке
dir - содержимое директории
javac - компиляция в байт код
java - вызов виртуальной машины и исполнение в ней программы
class ИмяКласса - всегда с большой буквы аналогично с названием файла.
args в main - это аргументы командной строки
______________________________________
Программа - алгоритм + структура данных
алгоритм - последовательность действий с пятью свойствами:
1) ввод
2) вывод
3) эффективность
4) конечность
5) однозначность/детерменированность
Теорема Бема-Якоппини - любой алгоритм можно выразить с помощью комбинации трех структур управления (на доске).  
_____________________________________________
УСТАНОВКА JDK:
JRE - Java Runtime Environment - Java окружение для выполнения программ (JVM)
JDK - JavaDevelopmentKit - набор инструментов (javac)
Установить JDK:
http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
<прописать путь к javac> переменные среды windows 10 java
java -version
javac -version в cmd либо в git bush
ПОДГОТОВКА К ДОМАШКЕ:
а) Скачать git for windows https://git-scm.com/downloads
б) установить Git Bush Only 
в) Регистрация https://github.com/
г) Скидываете мне ссылку на git: https://github.com/ВашЛогин в диалог
д) Переходите во вкладку Repositories
е) Нажимете кнопку new
ж) В Repository name вводите JAVA_IT_PARK_WORK
з) Нажимаете Create Repository
и) В пункте Quick Setup копируете строку с ссылкой
к) Запускаете Git Bush
л) Вводите cd Desktop
м) Вводите git clone https://github.com/ВашеИмя/JAVA_IT_PARK_WORK.git
н) Устанавливаете Sublime Text и открываете эту папочку в нем
о) Теперь вся ваша работа ведется в этой папке
п) Сделали всю свою работу - создаете папку HomeWorks - и в ней подпапки TaskНомерЗадачи
В каждой папке Program.java
р) В Git Bush делаете git status
c) git add .
т) делаем git commit -m 'add homework'
у) git push origin master - только один раз (потом git push).
ЗАМЕЧАНИЕ: 
Перед первым коммитом надо будет сделать
git config —global user.email [email регистрации]
git config —global user.name [ваше имя]
______________________________
ДЗ:
1. Посчитать произведение простых чисел в последовательности ( пока не -1)
2. Посчитать сумму чисел, порядок вхождения которых - четное число
34 - 1
56 - 2
78 - 3
21 - 4
-1
3. Посчитать произведение чисел, сумма цифр которых - простое число.
4. Развернуть массив на месте
5. Сумма элементов массива
6. прозизведение четных элементов массива, стоящих на нечетных позициях.
-------------------------------------------
Типы данных в java: int, double, boolean, char, short, byte, long, float (примитивные типы) - переменные данного типа, непосредственно хранят в себе значение.

Ссылочные - массивы.
------------------------------------
ДЗ:
7) Найти количество локальных максимумов в массиве. 
a[i-1]<a[i]>a[i+1], i = 1..n-2
Например: 1, 3, 2, 5, 4, 3, 1; - 3 и 5 - локальные максимумы

---------------------
Многомерные массивы в java - массив массивов
Функция:

public static ТИП_ВОЗВР_ЗНАЧЕНИЯ имя_функции(список_формальных_параметров) {
	// тело функции
	return значение;
}

Функции с одинаковыми названиями, но разными формальными параметрами называются перегруженными.

ДЗ:
В виде процедур и функций:
8) Найти среднее арифмитические в матрице
9) Найти минимальный элемент в каждой строке матрицы
10) Обнулить все элементы главной диагонали квадратной матрицы
11) Обнулить все элементы на побочной диагонали
12) Сделать разворот против часовой стрелки в квадратной матрице
13) Найти максимальный элемент в каждом столбце матрицы
14) Написать функцию проверки числа на простоту. (boolean-функция)
15) Написать функцию, возвращающую сумму цифр числа
----------------------------
ЗНАЕМ:
java - исполняет
javac - компилирует
Типы данных в java - примитивные/ссылочные
Переменные + явное/неявное приведение, операции / и %
if, while, for
функции и процедуры
Массивы - явная инициализация, многомерные массивы
Алгоритмы: поиск минимального, максимального, поменять местами значения, среднее арифметическое
Git - git clone, git add ., git commit, git push, git pull

Рекурсия - стек вызовов, терминальное условие рекурсии.

Ряд Фибонначи 
x[n] = x[n-1] + x[n-2], x[0] = 1, x[1] =1

x[2] = 2
x[3] = 3
x[4] = 5

ДЗ:
16) Оптимизировать вычисление Фибонначи
-------------------------------------------
Сортировка простыми вставками:

[42] [13] [5] [-10] [11] [2] [10]
   0    1   2     3    4   5    6

[0..6]
a = 0
b = 6
Минимальный элемент: -10
Меняем x[0] -> x[3], получаем:
[-10] [13] [5] [42] [11] [2] [10]

Теперь а = 1
[1..6], там минимальный - 2
 Определяем промежуток индексов [a..b]. 
 В этом промежутке находим минимальное число. Далее, заменяем минимальное число с числом x[a], изменяем промежуток a = a + 1, повторяем вычисления.
--------------------------------
ООП:
Парадигма программирования - способ организации вычислений внутри программы + стиль мышления программиста при решении задачи
Процедурная парадигма программирования: программа = алгоритм + структура данных
Функциональная парадигма:
программа - есть функция
Парадигма логического программирования: программа = набор логических предикатов (функции с true и false).
Парадигма ООП:
программа = объекты, которые обмениваются сообщениями.

ООП оперирует понятиями классов и объектов.

Объект - конкретная сущность, обладающая состоянием (свойствами) и поведением (действия).

Класс - абстрактный тип данных. Класс описывает то, каким поведением будут обладать созданные на основе класса объекты, и какие возможные состояния они могут иметь.

Возможное состояние объекта задается в классе.Задается с помощью полей (fields).

Инстантивация - выделение памяти и создание объекта (оператор new).

Инициализация - задание начального состояния

Конструктор - инициализатор (не является членом класса) - задачей конструктора является присвоение начальных значений полям объекта при создании.

Конструктор по умолчанию - конструктор, определенный для всех классов изначально. Конструктор по умолчанию имеет вид ClassName();
Он присваивает полям нулевые значения
int -> 0
double -> 0.0
String -> null
Для ссылочных типов -> null
boolean -> false
char - '\0'
Конструкторы можно переопределять. Как только вы описали свой конструктор, конструктор по умолчанию - отключается

ООП-разработчик:

Роль 1 - разработчик класса
Роль 2 - пользователь класса

Иногда возникает необходимость предоставить пользователю класса возможность проинициализировать объект своими данными. Для этого следует определить конструктор с параметрами

Инкапсуляция:
1) Совмещение алгоритмов и структур данных в одной сущности - классе.
Алгоритмы в классе реализуются в виде функций, структуры данных в виде полей.
Функции и процедуры внутри класса называются методами.
Методы - члены класса.
2) Защита внутренней структуры данных с помощью модификатора private - закрывает доступ к члену класса извне.

Поля всегда защищаем модификатор private
Если необходимо читать/изменять - делаем методы доступа - сеттеры геттеры.
Если необходимо только читать - только геттеры

5 классная) Описать класс Рациональное число
RaionalNumber.java
поля - числитель, знаменатель
конструктор с параметрами и без
метод нормализации - 5/2, метод должен вернуть 2.5

1) Один файл - один класс
2) Никакого транслита
3) int x = 6;
4) class Class {}

Объектные переменные (ссылочные переменные, указывающие на объект)

Модификаторы доступа:
public 
private
protected

Четыре уровня доступа
Открытый - public
Закрытый - private
Защищенный - protected
package internal - нет

Статическое поле - поле, глобальное для всех объектов класса.
Значение статического поля можно задать вызвав класс.

Статический инициализатор - инициализирует значения статических полей - работает ТОЛЬКО со статическими полями.

Статический метод - метод, вызов которого возможен без создания объекта, непосредственно из класса.
СТАТИЧЕСКИЙ МЕТОД ТОЖЕ СО СТАТИЧЕСКИМИ ПОЛЯМИ БЛИН
РЕЗЮМЕ:
Класс состоит из:
Закрытых полей
Конструкторов
Методы доступа
Прочие методы
Статические поля
Статические методы
Статические инициализаторы

n * n ~ O(n^2)

n^3 + n^2 + n ~ O(n^3)

СРЕДНИЙ ЛУЧШИЙ СЛУЧАЙ O(N * logN)
-------------------

Сортировка слиянием.

Слияние:
c[] <- merge(a[], b[])
a = {4, 5, 7, 10, 11}
b = {1, 2, 6, 8, 9, 13};

4 ~ 1 
c <- 1
4 ~ 2
c <- 2
4 ~ 6
c <-4
5 ~ 6
c <- 5
и т.д.

Реализовать класс Sort, в нем
статический метод merge(int a[], int b[])
https://github.com/IlyasGaynulin/JAVA_IT_PARK_WORK/blob/master/ClassWorks/Task6/Sort.java

Сортировка слиянием:

с = 10 -8 1 2 4 3 1 0
a = {10, -8, 1, 2}
b = {4, 3, 1, 0}
Сортировать c: 
 - Сортировать a
   - положить, что c = a
   	 c = {10, -8, 1, 2}
   	 a = {10, -8}
   	 b = {1, 2}
   	 Сортировать a, сортировать b
   	 Слить a и b
   	 - положить, что c = a
   	 c = {10, -8}
   	 a = {10}
   	 b = {-8}
   	 c <- {-8, 10};
Сортировать b
Слить а и b

ДЗ:
17) Создать массив людей, сортировать пузырьком по возрасту
18) Вывести количество всех возрастов от 1 до 120;
ДОП: разобрать код merge

Наследование - третий принцип ООП.
Предоставляет возможность объектам класса потомка
копировать и переопределять поведение и состояние
объектов класса предка.

extends - ключевое слово, которое показывает что класс наследуется.
class A extends B - класс А - потомок класса B
protected - модификатор доступа, соответствует уровню
доступа "защищенный". Члены класса, которые помечены как
protected видны в потомке
super(a,b,c) - вызов конструктора предка.
В конструкторе потомка вы всегда обязаны вызывать консруктор предка
в первую очередь.

Переопределение метода - это объявление в классе потомке
метода с идентичной сигнатурой метода класса предка, но
с другой реализацией

Полиморфизм - четвертый принцип ООП. С объектами разных
типов можно работать таким образом, будто они принадлежат
одному типу.

Восходящее преобразование - преобразование типа объектной переменной
с типа класса-потомка на тип класса-предка (НЕВНОЕ)


Task7 Создать класс SuperHero
У него два потомка - Mutants и Humans.
И у того и у того класса есть количество
 врагов.
Написать метод сортировки массива
супергероев
по количеству врагов.

Абстрактный класс (модификатор abstract) - класс, объекты
которого создавать нельзя.
Абстрактный метод - метод без реализации.
Данный метод необходимо реализовать в потомках.
Если в классе есть хотя бы один абстрактный метод,
класс нужно пометить как абстрактный.
Если в классе потомке абстрактный метод не реализован,
то класс-потомок тоже следует пометить как абстрактный.

У класса не может быть более одного предка.

Давайте подумаем:
Presentable - это инкапсуляция поведение, а для инкапсуляции
поведния подходят интерфейсы.

Интерфейс - это описание поведения. Классы реализующие (имплементирующие)
интерфейс обязуются реализовать ВСЕ методы интерфейса, иначе
они должны быть помечены как абстрактные.

Класс может реализовывать более одного интерфейса (просто перечисляем их
через запятую).

https://ru.wikipedia.org/wiki/%D0%90%D0%B3%D1%80%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

ЭКЗАМЕН:
1) Практическая
2) Теоретическая

1) Типы данных в Java
2) Приведение типов
3) Структуры управления + Теорема Бема-Якоппини
4) Подпрограммы - функции и процедуры (формальные параметры и аргументы)
5) Классы и объекты (структура, члены классов) + инкапсуляция
6) Статические члены классов
7) Инициализаторы
8) Наследование - protected, abstract, super.
9) Интерфейсы
10) Класс Object и его методы - equals и toString
11) Comparable + Comparator
12) Исключения
13) JavaIO
14) characters

19) Создать класс ParkingPlace (парковка
- парковать паркуемый объект 
- пусть он уедет с парковки по номеру
Класс содержит массив "паркуемых объектов"
ParkingObject - интерфейс
getNumber()
Паркуемый объект - parking() и unparking()
Есть иерархия классов:
Транспорт - абстрактный
Машина
Мотоцикл
Велосипед - не паркуемый объект!!!
Перепределить equals, toString

Коллекции - набор элементов

Список - абстрактный тип данных
поддерживающий операции:
добавить элемент в список
вставить элемент в список
удалить элемент по номеру
получить элемент по номеру
найти элемент по значению
развернуть список
получить количество

20) Дореализовать ArrayList

Object - предок всех классов. Да, всех. Абсолютно всех, нет классов которые не являются его потомками.
Ваш класс, который вы написали, тоже потомок Object

== - сравнивает значения примитивных типов
в случае ссылочных типов проверяет эквивалентность ссылок

Задача - алгоритмы сортировки - как сортировать
одним алгоритмом объекты разной природы?
Определить интерфейс Comparable с методом
compareTo(Object object) и реализовать его
в классе сортируемых объектов
Если нас не устраивает реализованный compareTo
то описываем свой интерфейс Comparator и там
уже говорим, как сравнивать объекты


-------------------------------
Ислючительная ситуация - неккоректная работа
программы в момент выполнения
Для каждой исключительной ситуации в java
описан класс.
StackOverflowError
OutOfMemoryError
ArithmeticException

Чтобы перехватить исключение необходимо:

try - помечаем блок кода, в которой может возникнуть
исключительная ситуация
catch(E e) - блок, в котором мы описываем, что
нужно делать, если перехвачена ошибка типа E
e - объект ошибки
throw new - выброс ошибки

TASK 8

Описать класс верификатор
в нем сделать проверку корректности пароля:
Метод verify принимает на вход пароль,
и выдает PasswordException, если длина пароля
меньше 6 символов. В противном случае, ничего не делает.
В мейне - считать пароль и проверить на корректность.
Если выскочила ошибка PasswordException
попросите пользователя ввести заново.

В Java следующая иерархия исключений:
Throwable - все, что может быть
выбрашено в качестве исключения
Два потомка Throwable:
Error - ошибки системы (его потомок VirtualMachineError,
потомками которого в свою очередь являются StackOverflowError и OutOfMemoryError)
ВСЕ ЭРРОРЫ МОЖНО ПЕРЕХВАТЫВАТЬ try-catch
Exception - все проверяемые исключения (то есть те, которые вы обязаны обработать либо пробросить наверх throws)

Поток (Stream) не путать с Потоком (Thread)
- последовательность байтов
При запуске программы по умолчанию
открываются три потока
System.out
System.err
System.in

JavaIO - набор классов для работы с вводом-выводом
В иерархии классов наверху находятся
InputStream и OutputStream

InputStream - абстрактный класс, описывает поведение
чтения потока с методами
read()
read(byte b[])
FileInputStream - файловый поток

ТАБЛИЦА СИМВОЛОВ - таблица, где каждому
символу сопоставляется число, которое копьютер
может как-то идентифицировать.

Набор символов определяется кодировкой
Если файл закодирован кодировкой ASCII, то каждый
символ в этом файле весит 1 байт.
ASCII
0 - 31 - Управляющие символы
примеры:

0 -
1 -
9 - таб
10 - новая строка
13 -возврат каретки
...
33 - 126 - символы, цифры и буквы английского алфавита

UNICODE - один символ - 2 байта

ДЗ
21) написать функцию конвертации числа как строки
вход - char[] ~ '3','2','1'
выход - 321 (int)



ДЗ
Экзамен
ДЗ ParkingPlace -
Ильяс,
Айдар,
Михаил,
Алина,
Марсель

10-я задача
Создать проект Task10
Список фигур записать в файл
1) Описать классы фигур
2) переопределить toString
3) OutputStream - записать в файл список фигур

-----------
20) Сделать ArrayList обобщенным
ИЗУЧИТЬ ОБОБЩЕНИЯ В Compare

Связный список (LinkedList) - структура данных,
представляющая собой набор элементов.
Каждый элемент хранится в узле (Node) связного списка.
Каждый узел списка состоит обязтаельно из двух полей:
Value - значение элемента списка
Next - указатель на следующий элемент списка

ДОП: читать про внутренние классы и вложенные классы

DAO - паттерн проектирования
Data Access Object - объект доступа к данным
Проблема:
    данные могут хранится в каком угодно виде,
    при этом часто формат хранения данных меняется
    необходимо разделить логику работы системы
    и логику работы с хранилищем данных

Singleton
Properties-файл
Iterator

ДЗ:
1) Повторить
Сделать:
22)Реализовать метод findAll в HumansDao через LinkedList или ArrayList
который написали вы сами.
23) В LinkedList реализовать remove(int index)
Реализовать reverse() - разворот связоного списка
--------------

Задача: научиться хранить 
данные типа <Ключ, Значение>,таким образом
чтобы мгновенно получать доступ 
к значению по ключу.

Пусть ключ - строка.
Мы знаем, что в массиве доступ к элементу по 
ключу-индексу моментальный. Значит надо
научиться преобразовывать ключ-строку в индекс.

Пусть имеем безразмерный массив A
[ ] [ ] [ ] ... [ ] - значения
 0   1   2      m - 1 - ключи-индесы
 
 1) Пусть есть строка ABBC, ее ключ-индекс считаем
 как сумму кодов символов
H1 = (int)'A' + (int)'B' + 
(int)'B' + (int)'C', данное число и будет 
индексом, где храним ключ ABBC
ПРОБЛЕМА - что H1(BABC) = H1(ABBC), в одну 
ячейку кладем два ключа - это плохо.
Решение: учитывать позицию

H1 = S[0] + S[1] + ... + S[n - 1]
предложим H2:

H2 = w1 * S[0] + w2 * S[1] + ... + wn * s[n - 1]
wi при S[i] будем считать как p^i
ВОПРОС: каким должно быть p?
p - четное, появляется множитель 2.
Пусть имеем число x = 113, его двоичный код - 1110001
Умножим его на 2: x = 226, его двоичный код -11100010
Умножим еще раз на 2: x = 452, 				111000100
Если брать p-четным, мы постоянно теряем информацию
Умножение на два - это сдвиг влево на один бит.
p - нечетное, пусть 63 - 3, 7, 9, 21
Если в сумме будут всплывать комбинации этих чисел
3 * 21, 9 * 7, 3 * 3 * 7.
p - ПРОСТЫЕ
Обычно p = 31
Таким образом, формула получения ключа-индекса
из ключа-строки
H = SUM 31 ^ i * S[i], i = 0..n-1
H - хеш-код

-------------------------------------------

Хеш-код получили, но он нереально огромный
Надо урезать до размеров массива.
Как вариант можно оставить последние биты, которых
достаточно для определения индекса.

Маска - битовая последовательность, которая позволяет
маскировать другую битовую последовательность:

маска - 110011
исходная последовательность - 001110

Применяем маску через конъюнкция (И)
110011
001110
------
000010 - результат масирования

--------------------------------
Исходная строка - Marsel
Ее хеш -1997431204
Хеш в двоичном коде - 10001000111100011001111001011100
Размер массива - 11
Маска 11 - 1 = 10, в двоичном коде 1010
Применяем маску:
10001000111100011001111001011100
							1010
							----
							1000 - 8, позиция
							
При плохом выборе размера массива, а следовательно
маски, могут возникнуть КОЛЛИЗИИ, когда одна позиция
на несколько ключей.
ПОДОБРАТЬ ПРАВИЛЬНО РАЗМЕР!
2^k - 1



-----------------
Работа с двоичными числами в комьютере:

-12 в десятичной - 11110100

Помним, что первый бит отводится под знак.

23 - 12, компьютеру не удобно вычитать, он заменит
операцию вычитания сложением:
23 + (-12), как получить -12?
Пусть у нас число хранится в одном байте, тогда:
12 -> 00001100
Получаем обратный код:
-> 11110011
-> Получаем дополнительный код, к обратному прибавляем
единичку
-> 
 11110011
		1
---------
 11110100


Возвращаемся к 23 - 12
	00010111
    11110100
	--------
   100001011 -> 1011

-------------------------
Проблема - коллизии так и так будут, потому что
места всегда мало.

Решение метод цепочек - каждый элемент массива 
- связный список.

Map - АТД, карта, словарь, ассоциативный массив
Таблица Ключей и Значений.
Где ключ - любой объект.
----------------------
Если в классе A необходима функциональность класса B:
1) Плохой - наследование (изменение B влечет изменения в A)
2) Лучше - агрегирование (в A есть поле B)
3) самый лучший - агрегирование со слабой связью
Делаем прослойку интерфейс.
+ можно подменить реализацию в любой момент
+ измение функциональности реализаций интерфейса никак 
не отражается на исходном классе
----------------------------
Рефлексия - возможность работать с классами
как с объектами
Получить объект-класс H типа Class:
Class clazz = H.class;
clazz.getFields() - получить все открытые поля
clazz.getDeclaratedFields() - получить все поля, в том числе закрытые.

ДЗ:
24) Реализовать в HashMap 
V get(K key)
25) Поработать с методами в рефлексии, получить метод класса и вызвать его.

----------------------------------
РАЗБОР ДЗ:
9 - вернуть МАССИВ МИНИМАЛЬНЫХ
13 - аналогично
16 - скинул в вк
18 - у вас массив чисел [0..120], массив людей
у каждого возраст
for (int i = 0; i < humans.length; i++) {
	int currentAge = humans[i].getAge();
	ages[currentAge]++;
}
19) Парковка:
ParkingPlace
 - ParkingObject[]
	+ park()
	+ unpark()
	
не все транспорты паркуемые!!!
21) "12345" -> int = 12345
----------------------------------




